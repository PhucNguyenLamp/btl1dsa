#include <fstream>
#include <iostream>
#include <string>
#include <math.h>

using namespace std;
//main.h
int MAXSIZE;
class Restaurant {

	public:
		Restaurant() {};
		~Restaurant() {};
		virtual void RED(string name, int energy) = 0;
		virtual void BLUE(int num) = 0;
		virtual void PURPLE() = 0;
		virtual void REVERSAL() = 0;
		virtual void UNLIMITED_VOID() = 0;
		virtual void DOMAIN_EXPANSION() = 0;	
		virtual void LIGHT(int num) = 0;
		public:
			class customer {
			public:	
				string name;
				int energy;
				customer* prev;
				customer* next;
			public:
				customer(){}
				customer(string na, int e, customer* p, customer *ne): name(na), energy(e), prev(p), next(ne){}
				~customer(){};
				void print() {
					cout << name << "-" << energy << endl;
				}
			};
};
//Restaurant.cpp
class imp_res : public Restaurant
{	
	public:
		class DCLList {
		private:
			customer* head;
			customer* curr;
			int size;
		public:
		DCLList() {
			head = nullptr;
			curr = nullptr;
			size = 0;
		}
		~DCLList(){
			// 
			for (int i=0; i<size; i++){
				customer* temp = curr;
				curr = curr->next;
				delete temp;
			}
		}
		void setcurr(customer* c){
			curr = c;
		}
		void add(string name, int energy){
			if (size == 0) {
				head = new customer(name, energy, nullptr, nullptr);
				head->next = head->prev = head;
				curr = head;
				}
			else if (size == 1){
				curr->next = new customer(name, energy, curr, curr);
				curr->prev = curr->next;
				curr = curr->next;
			} else {
				customer* temp = new customer(name, energy, curr, curr->next);
				curr->next->prev = temp;
				curr->next = temp;
				curr = temp;
			}
			size++;
		}
		void addbefore(string name, int energy){
			if (size == 0) {
				head = new customer(name, energy, nullptr, nullptr);
				curr = head;
				}
			else if (size == 1){
				head->next = new customer(name, energy, head, head);
				head->prev = head->next;
				curr = head->next;
			} else {
				customer* temp = new customer(name, energy, curr->prev, curr);
				curr->prev->next = temp;
				curr->prev = temp;
				curr = temp;
			}
			size++;
		}
		void remove(){ // xoa ngay vi tri con tro curr
			if (size == 0){
				return;
			}
			else if (size == 1){
				customer* temp = curr;
				delete temp;
				curr = nullptr;
				head = nullptr;
				size--;
				return;
			}
			else if (size == 2){
				customer* temp = curr;
				curr = curr->next;
				curr->next = curr;
				curr->prev = curr;
				size--;
				delete temp;
				return;
			}
			else {
				customer* temp = curr;
				int energy = curr->energy;
				curr->next->prev = curr->prev;
				curr->prev->next = curr->next;
				if (energy > 0) {
					curr = curr->next;
				} else {
					curr = curr->prev;
				}
				size--;
				delete temp;
				return;
			}
		}
		void remove(string name){
			customer* temp = curr;
			int energy = curr->energy;
			for (int i=0; i < size; i++){
				if (temp->name == name){
					if (size == 0){
						return;
					}
					else if (size == 1){
						curr = nullptr;
						head = nullptr;
						size--;
						delete temp;
						return;
					}
					else if (size == 2){
						customer* tempdelete = temp;
						temp->next->prev = temp->prev;
						temp->prev->next = temp->next;
						curr = temp->next;
						size--;
						delete tempdelete;
						return;
					} else {
						temp->next->prev = temp->prev;
						temp->prev->next = temp->next;
						if (energy > 0) {
							curr = temp->next;
						} else {
							curr = temp->prev;
						}
						size--;
						delete temp;
						return;
					}
				}
				temp = temp->next;
			}
			return;
		}
		customer* get(){
			return curr;
		}
		int getSize(){
			return size;
		}
		bool isEmpty(){
			return size == 0;
		}
		void next(){
			curr = curr->next;
		}
		void prev(){
			curr = curr->prev;
		}
		bool check(string name){
			customer* temp = curr;
			for (int i = 0; i < size; i++){
				if (temp->name == name) return true;
				temp = temp->next;
        }
        return false;
    	}
	};
		class LQueue {
		private:
			customer* head;
			customer* rear; 
			customer* curr;
			int size;
		public:
		LQueue() {
			head = nullptr;
			rear = nullptr;
			size = 0;
		}
		LQueue(LQueue* q){
			// deep copy
			head = nullptr;
			rear = nullptr;
			size = 0;
			customer* temp = q->head;
			for (int i=0; i<q->size; i++){
				add(temp->name, temp->energy);
				temp = temp->next;
			}
		}
		~LQueue(){
			while (head != nullptr) {
            customer* temp = head;
            head = head->next;
            delete temp;
        	}
		}
		void add(string name, int energy){
			if (size==0){
				head = rear = new customer(name, energy, nullptr, nullptr);
			} else {
				rear->next = new customer(name, energy, nullptr, nullptr);
				rear = rear->next;
			}
			size++;
		}
		void remove(){
			if (size == 0) return;
			else if (size == 1){
				customer* temp = head;
				head = rear = nullptr;
				size--;
				delete temp;
			} else {
				customer* temp = head;
				head = head->next;
				size--;
				delete temp;
			}
		}
		// customer* removeAt(int i){
		// 	if (i == 0) return remove();
		// 	else if (i == size - 1){
		// 		customer* temp = rear;
		// 		curr = head;
		// 		for (int i=0; i<size-2; i++){
		// 			curr = curr->next;
		// 		}
		// 		rear = curr; // detach rear luon
		// 		size--;
		// 		return temp;
		// 	} else {
		// 		curr = head;
		// 		for (int j=0; j<i-1; j++){ //ng·ª±a h√≠ h√≠ üê¥
		// 			curr = curr->next;
		// 		}
		// 		customer* temp = curr->next;
		// 		curr->next = curr->next->next;
		// 		size--;
		// 		return temp;
		// 	}
		// }
		void remove(string name){
			if (size == 0) return;
			customer* temp = head;
			for (int i=0; i< size; i++){
				if (temp->name == name) return removeAt(i);
				temp = temp->next;
			}
			return;
		}
		customer* get(){
			return head;
		}
		// void clear(){
			// ch∆∞a c·∫ßn
		// }
		int getSize(){
			return size;
		}
		bool check(string name){
			customer* temp = head;
			for (int i = 0; i < size; i++){
				if (temp->name == name) return true;
				temp = temp->next;
			}
			return false;
		}
		bool isEmpty(){
			return size == 0;
		}
		void moveTo(int n){
			if (n >= size) n = size - 1;
			curr = head;
			for (int i = 0; i < n; i++){
				curr = curr->next;
			}
		}
		customer* getcurr(){
			return curr;
		}
		customer* getat(int n){
			moveTo(n);
			return curr;
		}
		int getPos(){
			customer* temp = head;
			int i = 0;
			while (temp != curr){
				temp = temp->next;
				i++;
			}
			return i;
		}
		void next(){
			curr = curr->next;
		}
		void prev(){
			// if < 0 return
			moveTo(getPos()-1);
		}
		void swap(int a, int b){
			moveTo(a);
			customer* temp = curr;
			moveTo(b);
			customer* temp2 = curr;
			std::swap(temp->energy, temp2->energy);
			std::swap(temp->name, temp2->name);
		}
		void removeAt(int n){
			moveTo(n);
			customer* temp;
			if (n == 0){
				temp = head;
				head = head->next;
				size--;
				delete temp;
			} else if (n == size - 1){
				temp = rear;
				moveTo(n-1);
				rear = curr;
				size--;
				delete temp;
			} else {
				temp = curr;
				moveTo(n-1);
				curr->next = curr->next->next;
				size--;
				delete temp;
			}
		}
	};

	public:
		DCLList *table;
		LQueue *queue;
		LQueue *history;

		imp_res() {
			table = new DCLList();
			queue = new LQueue();
			history = new LQueue();
		};
		~imp_res(){
			delete table;
			delete queue;
			delete history;
		}
		void RED(string name, int energy)
		{	
			// cout << name << " " << energy << endl;
			bool check = table->check(name) || queue->check(name); // true l√† b·ªã tr√πng
			if (energy != 0 && table->getSize() < MAXSIZE && !check){
				if (table->getSize()<=1){
					table->add(name, energy);
				} else if (!(table->getSize() >= MAXSIZE/2)) {
					if (table->get()->energy <= energy){ //energy khach >= energy ban
						table->add(name, energy);
					} else {
						table->addbefore(name, energy);
					}
				} else if (table->getSize() >= MAXSIZE/2){
					int max = abs(energy - table->get()->energy);
					customer* maxcus = table->get();
					customer* x = table->get();
					x = x->next;
					while (table->get() != x){
						if (max < abs(energy - x->energy)){
							max = abs(energy - x->energy);
							maxcus = x;
						}
						x = x->next;
					}
					int noabsmax = energy - maxcus->energy;

					table->setcurr(maxcus);
					if (noabsmax < 0){
						table->addbefore(name, energy);
					} else {
						table->add(name, energy);
					}
				}
				history->add(name, energy);
			} else if (energy != 0 && queue->getSize()<MAXSIZE && !check) {
				queue->add(name, energy);
			}
		}
		void BLUE(int num)
		{ //history
			// cout << "blue "<< num << endl;
			if (num >= table->getSize()){
				num = table->getSize();
			}
			//kick khach cu nhat //ko can kiem tra vi = getsize
			for (int i = 0; i < num; i++){
				int removedenergy = history->get()->energy;
				string removedname = history->get()->name;
				history->remove();

				customer* temp = table->get();
				for (int j=0; j<table->getSize();j++){
					if (temp->name == removedname){
						string tempname = temp->name;
						temp = temp->next;
						table->remove(tempname);
						break;
					}
						temp = temp->next;
				}
			}
			//pop queue
			//chay red
			while (!(queue->isEmpty())&&table->getSize()<MAXSIZE){
				string removedname = queue->get()->name;
				int removedenergy = queue->get()->energy;
				queue->remove();
				RED(removedname, removedenergy);
			}
		}
		void inssort2(LQueue *head, int n, int incr, int& swapcount){
			for (int i=incr; i<n; i+=incr){
				for (int j=i; (j>=incr) && (abs(head->getat(j)->energy) > abs(head->getat(j-incr)->energy)); j-=incr){
					head->swap(j, j-incr);
					swapcount++;
				}
			}
		}
		void shellsort(LQueue *head, int n, int& swapcount){
			for (int i=n/2; i>2; i/=2){
				for (int j=0; j<i; j++){
					inssort2(head, n-j, i, swapcount);
				}
			}
			inssort2(head, n, 1, swapcount);
		}
		void PURPLE()
		{
			// cout << "purple"<< endl;
			//xep queue; //n·∫øu c√≥ queue

			// abs() t·ª´ l·ªõn ƒë·∫øn b√©
			if (!queue->isEmpty()){
			int maxenergy = abs(queue->get()->energy);
			int maxindex = 0;
			int N = 0;
			for (int i=1;i<queue->getSize();i++){
				if (abs(queue->getat(i)->energy) >= maxenergy){
					maxenergy = queue->getat(i)->energy;
					maxindex = i;
				}
			}
			// sort from 0 to i
			LQueue *begin = new LQueue(queue);
			shellsort(queue, maxindex+1,N);
			// fix the stable of the queue after sorting
			for (int i=0; i<queue->getSize()-1; i++){
				//move queue den cho do
				queue->moveTo(i);
				// neu 2 thang bang nhau -> check xem co dung thu tu ko
				if (queue->getcurr()->energy == queue->getcurr()->next->energy){
					// lay thu tu cua curr va curr next
					string namecurr = queue->getcurr()->name;
					string namecurrnext = queue->getcurr()->next->name; 
					// lay thu tu cua curr va curr nexg trong begin
					int currindex = 0;
					int currnextindex = 0;
					for (int j=0; j<begin->getSize(); j++){
						begin->moveTo(j);
						if (begin->getcurr()->name == namecurr){
							currindex = j;
						}
						if (begin->getcurr()->name == namecurrnext){
							currnextindex = j;
						}
					}
					if (currindex > currnextindex){
						// neu sai thu tu -> swap
						queue->swap(i, i+1);
					}
				}
			}
			BLUE(N%MAXSIZE);
			}
		}
		void REVERSAL()
		{
			// cout << "reversal" << endl;
			//replace duong
			string temp = table->get()->name;
			LQueue* tempq = new LQueue();
			customer* tempcus = table->get();
			int len = table->getSize();
			// int qlen = 0;
			for (int i=0; i<len; i++){
				if (tempcus->energy > 0){
					tempq->add(tempcus->name, tempcus->energy);
					// qlen++;
				}
				if (i!=len-1) tempcus = tempcus->prev;
			}
			for (int i=0; i<len; i++){
				if (tempcus->energy > 0){
					tempcus->energy = tempq->get()->energy;
					tempcus->name = tempq->get()->name;
					tempq->remove();
				}
				tempcus = tempcus->next;
			}
			//replace √¢m
			delete tempq;
			tempq = new LQueue();
			tempcus = table->get();
			// qlen = 0;
			for (int i=0; i<len; i++){
				if (tempcus->energy < 0){
					tempq->add(tempcus->name, tempcus->energy);
					// qlen++;
				}
				if (i!=len-1) tempcus = tempcus->prev;
			}
			for (int i=0; i<len; i++){
				if (tempcus->energy < 0){
					tempcus->energy = tempq->get()->energy;
					tempcus->name = tempq->get()->name;
					tempq->remove();
				}
				tempcus = tempcus->next;
			}
			
			delete tempq;
			// set lai x
			tempcus = table->get();
			for (int i=0; i<len; i++){
				if (tempcus->name == temp){
					table->setcurr(tempcus);
				}
				tempcus = tempcus->prev;
			}
		}
		void UNLIMITED_VOID()
		{
			// cout << "unlimited_void" << endl;
			//bo truong hop < 4
			int len = table->getSize();
			if (len < 4) return;
			customer *left = table->get();
			customer *right = table->get()->next->next->next;
			//init
			int minoutersum;
			for (int i=0; i<len; i++){
				customer* templeft = table->get(); 
				int sum = 0;
				//dich chuyen
				for (int k=0; k<i;k++){
					templeft = templeft->next;
				}
				customer *temp = templeft;
				customer *tempright = templeft->next->next->next;
				//get tong 4 cai dau
				for (int j=0; j<4;j++){
					sum += temp->energy;
					temp = temp->next;
				}
				//nho nhat
				int minsum = sum;
				temp = tempright;
				//so sanh nhung cai sau
				for (int l=4; l<len;l++){
					temp = temp->next;
					sum += temp->energy;
					if (sum <= minsum){
						minsum = sum;
						//move to
						tempright = temp;
					}
				}

				if (i==0){
					minoutersum = minsum;
				} else if (minsum <= minoutersum){
					minoutersum = minsum;
					//move to
					left = templeft;
					right = tempright;
				}
			}
			// co l r
			// co dc day nho nhat
			// tim phan tu nho nhat
			customer* smallest = left;
			customer* temp = left;
			int count = 1; //hjhj
			while (temp!=right){
				count++;
				temp = temp->next;
			}
			temp = left;
			// temp = temp->next;
			for (int i=0; i<count; i++){
				if (smallest->energy > temp->energy){
					smallest = temp;
				}
				temp = temp->next;
			}
			// in ra tu nho nhat den cuoi theo chieu dong ho
			temp = smallest;
			count = 1;
			while (temp!=right){
				count++;
				temp = temp->next;
			}
			temp = smallest;

			customer* temp2 = left;
			int count2 = 0;
			while (temp2!=temp){
				count2++;
				temp2 = temp2->next;
			}
			temp2 = left;
			for (int i=0; i<count; i++){
				cout << temp->name << "-" << temp->energy << endl;
				temp = temp->next;
			}
			for (int i=0; i<count2; i++){
				cout << temp2->name << "-" << temp2->energy << endl;
				temp2 = temp2->next;
			}
		}
		void DOMAIN_EXPANSION()
		{
			// cout << "domain_expansion" << endl;
			int chewTwerkShoe = 0;
			int oanTLinh = 0;
			//get cho chu thuat su
			customer* tablecurr = table->get();
			queue->moveTo(0);
			customer* queuecurr = queue->get();
			for (int i=0; i<table->getSize();i++){
				if (tablecurr->energy > 0) chewTwerkShoe += tablecurr->energy;
				tablecurr = tablecurr->next;
			}
			for (int i=0; i<queue->getSize();i++){
				if (queuecurr->energy > 0) chewTwerkShoe += queuecurr->energy;
				queuecurr = queuecurr->next;
			}
			//get cho oan linh
			tablecurr = table->get();
			queue->moveTo(0);
			queuecurr = queue->get();
			for (int i=0; i<table->getSize();i++){
				if (tablecurr->energy < 0) oanTLinh += tablecurr->energy;
				tablecurr = tablecurr->next;
			}
			for (int i=0; i<queue->getSize();i++){
				if (queuecurr->energy < 0) oanTLinh += queuecurr->energy;
				queuecurr = queuecurr->next;
			}
			if (chewTwerkShoe==0||oanTLinh==0){
				return;
			}
			if (chewTwerkShoe>=abs(oanTLinh)){
				//kick oantlinh
				//kick queue // g·∫ßn ƒë√¢y nh·∫•t (t·ª´ ƒëu√¥i ƒë·∫øn ƒë·∫ßu)
				int queueSize = queue->getSize();
				for (int i=queueSize-1; i>=0;i--){
					queue->moveTo(i);
					if (queue->getcurr()->energy < 0){

						//customer* temp = queue->removeAt(i);
						int energy = queue->getat(i)->energy;
						string name = queue->getat(i)->name;
						queue->removeAt(i);
						cout << name << "-" << energy << endl;
					}
				}
				//kick history (table) 
				int historySize = history->getSize();

				for (int i=historySize-1; i>=0;i--){
					history->moveTo(i);
					if (history->getcurr()->energy < 0){
						// customer* temp = history->removeAt(i);
						int energy = history->getat(i)->energy;
						string name = history->getat(i)->name;
						history->removeAt(i);
						table->remove(name);
						cout << name << "-" << energy << endl;
					}
				}
			}else{
				//kick chewtwerkshoe
				//kick queue
				int queueSize = queue->getSize();
				for (int i=queueSize-1; i>=0;i--){
					queue->moveTo(i);
					if (queue->getcurr()->energy > 0){
						// customer* temp = queue->removeAt(i);
						int energy = queue->getat(i)->energy;
						string name = queue->getat(i)->name;
						queue->removeAt(i);
						cout << name << "-" << energy << endl;
					}
				}
				//kick history (table)
				int historySize = history->getSize();
				for (int i=historySize-1; i>=0;i--){
					history->moveTo(i);
					if (history->getcurr()->energy > 0){
						// customer* temp = history->removeAt(i);
						int energy = history->getat(i)->energy;
						string name = history->getat(i)->name;
						history->removeAt(i);
						table->remove(name);
						cout << name << "-" << energy << endl;
					}
				}
			}
			//chay red
			while (!(queue->isEmpty())&&table->getSize()<MAXSIZE){
				//customer* temp = queue->remove();
				customer* temp = queue->get();
				int energy = temp->energy;
				string name = temp->name;
				queue->remove();

				RED(name, energy);
			}
			/*‚ÄúLu·∫≠n v·ªÅ Y√™u‚Äù hay l√† ‚ÄúCon ch√≥ v√† Th·∫±ng Osin‚Äù
				Ch·∫Øc h·∫≥n nhi·ªÅu b·∫°n trai, ƒë·∫∑c bi·ªát l√† c√°c b·∫°n hay ƒë·ªçc di·ªÖn ƒë√†n f17 VoZ kho·∫£ng nƒÉm 2010 ƒë·∫øn 2013 kh√¥ng l·∫° l·∫´m g√¨ v·ªõi h·ªçc thuy·∫øt Con ch√≥ v√† th·∫±ng Osin. H·ªçc thuy·∫øt n√†y c√≥ n·ªôi dung ng·∫Øn g·ªçn nh∆∞ sau: B·∫•t k√¨ c√¥ g√°i xinh ƒë·∫πp v√† kh√¥n ngoan n√†o (chu·∫©n hotgirl hi·ªán nay) ƒë·ªÅu c√≥ hai ng∆∞·ªùi b·∫°n trai ch√≠nh. M·ªôt l√† Con Ch√≥ ‚Äî gi√†u c√≥, ƒë·∫πp trai, ƒëi x·∫ø x·ªãn ‚Äî ƒë∆∞·ª£c c√°c c√¥ d√πng ƒë·ªÉ khoe v√† ch·ª©ng t·ªè gi√° tr·ªã c·ªßa b·∫£n th√¢n v·ªõi thi√™n h·∫°. Hai l√† Th·∫±ng Osin ‚Äî chƒÉm ch·ªâ, hi·ªÅn l√†nh, ƒëa ph·∫ßn l√† h·ªçc gi·ªèi ‚Äî lu√¥n th·ªù ph·ª•ng v√† s·∫µn s√†ng l√†m m·ªçi vi·ªác c√°c c√¥ y√™u c·∫ßu t·ª´ l√†m b√†i t·∫≠p h·ªô ƒë·∫øn ƒë√≥n th·∫±ng em trai. Tuy nhi√™n Th·∫±ng Osin s·∫Ω kh√¥ng bao gi·ªù ƒë∆∞·ª£c b∆∞·ªõc ra √°nh s√°ng cu·ªôc ƒë·ªùi c√πng v·ªõi c√°c c√¥, ƒë∆°n gi·∫£n v√¨ Osin kh√¥ng b√≥ng b·∫©y b·∫±ng Con Ch√≥.

				L·∫Ω dƒ© nhi√™n h·ªçc thuy·∫øt n√†y mang n·∫∑ng m√πi cay ƒë·∫Øng ƒë·ªï v·ª° t√¨nh ƒë·∫ßu c·ªßa c√°c c·∫≠u trai m·ªõi l·ªõn, v√¨ v·∫≠y kh√¥ng h·ªÅ mang t√≠nh kh√°ch quan ph·ªï qu√°t. Nh∆∞ng m√¨nh mu·ªën n√≥i t·ªõi m·ªôt kh√≠a c·∫°nh kh√°c, ƒë∆∞·ª£c ch·∫•p nh·∫≠n r·ªông r√£i h∆°n c·ªßa h·ªçc thuy·∫øt n√†y.

				ƒêa ph·∫ßn ch√∫ng ta cho r·∫±ng c·∫£ Con Ch√≥ v√† Th·∫±ng Osin ƒë·ªÅu r·∫•t ngu d·ªët khi ƒë·∫ßu t∆∞ m√π qu√°ng v√†o m·ªôt m·ªëi quan h·ªá v√¥ b·ªï nh∆∞ v·∫≠y. Th·∫≠m ch√≠ ƒë√¥i l√∫c ch√∫ng ta c√≤n th∆∞∆°ng c·∫£m cho h·ªç, ƒë·∫∑c bi·ªát l√† Th·∫±ng Osin. Ch·∫Øc h·∫≥n ngo√†i ƒë·ªùi th·ª±c b·∫°n ƒë√£ g·∫∑p v√†i Th·∫±ng Osin nh∆∞ v·∫≠y. ƒê∆∞a ƒëi ƒë√≥n v·ªÅ nh∆∞ xe √¥m ri√™ng, chƒÉm s√≥c h∆°n c·∫£ chƒÉm b√† ƒë·∫ª, ngoan ngo√£n v√¢ng d·∫° nh∆∞ ch√°u nghe l·ªùi b√† n·ªôi‚Ä¶ ƒë·ªÉ cu·ªëi c√πng tr·ªü th√†nh b·∫°n th√¢n (friendzone), anh trai (brotherzone), b·ªë (familyzone)‚Ä¶ Th·∫≠t l√† h·∫øt s·ª©c th·∫£m th∆∞∆°ng v√† t·ªá b·∫°c!

				Thanks, Obama‚Ä¶
				S·ª± th∆∞∆°ng c·∫£m v√† b·∫•t b√¨nh c·ªßa ch√∫ng ta ch·ªß y·∫øu ƒë·∫øn t·ª´ k·∫øt lu·∫≠n cho r·∫±ng Th·∫±ng Osin ƒë√£ ƒë·∫ßu t∆∞ qu√° nhi·ªÅu v√†o m·ªëi quan h·ªá m√† kh√¥ng nh·∫≠n ƒë∆∞·ª£c g√¨. Theo kinh t·∫ø h·ªçc, ƒë√¢y l√† m·ªôt kho·∫£n ƒë·∫ßu t∆∞ ho√†n to√†n th·∫•t b·∫°i. Theo ph·∫°m tr√π ƒë·∫°o ƒë·ª©c th√¥ng th∆∞·ªùng, sau bao nhi√™u hy sinh v√† c·ªëng hi·∫øn nh∆∞ v·∫≠y, Th·∫±ng Osin x·ª©ng ƒë√°ng ƒë∆∞·ª£c c√¥ n√†ng ƒë·ªÅn ƒë√°p m·ªôt t√¨nh y√™u ch√¢n th√†nh.

				V√¨ nh·ªØng ƒë√°nh gi√° v√† b·∫•t b√¨nh nh∆∞ tr√™n, n·∫øu Th·∫±ng Osin kia c√≥ m·ªëi quan h·ªá g·∫ßn g≈©i v·ªõi ch√∫ng ta (b·∫°n b√®, h·ªç h√†ng‚Ä¶) ch√∫ng ta s·∫Ω t√¨m c√°ch ‚Äúch·ª≠i cho n√≥ s√°ng m·∫Øt ra‚Äù v√¨ ‚Äúkh√¥ng th·ªÉ ƒë·ªÉ n√≥ t·ª± l√†m kh·ªï m√¨nh nh∆∞ th·∫ø m√£i ƒë∆∞·ª£c‚Äù v·ªõi nh·ªØng m·ªánh ƒë·ªÅ quen thu·ªôc nh∆∞:

				N√≥ cho m√†y c√°i g√¨ ƒë√¢u m√† m√†y v√¨ n√≥ th·∫ø?
				Tao th·∫•y m√†y nh·ª•c vƒë m√† c√≥ ƒë∆∞·ª£c c√°i g√¨ ƒë√¢u?
				Xu h∆∞·ªõng kh·ªï d√¢m √†?
				Sao m√†y ngu v√† c·ªë ch·∫•p th·∫ø? ‚Äî L√∫ t√¨nh √†? ‚Äî ƒÇn ph·∫£i b·∫£ c·ªßa n√≥ √†?
				Tao n√≥i ƒë nghe sau n√†y b·ªã n√≥ ph≈© th√¨ ƒë·ª´ng kh√≥c l√≥c.
				Nh∆∞ng s·ª± th·∫≠t li·ªáu c√≥ ph·∫£i nh∆∞ v·∫≠y? Li·ªáu c√≥ ƒë√∫ng l√† Th·∫±ng Osin ‚Äúngu ng∆°‚Äù, ‚Äúb·ªã l√∫ t√¨nh‚Äù, ‚Äúcho ƒëi kh√¥ng h·ªÅ nh·∫≠n l·∫°i‚Äù ƒë√∫ng nh∆∞ nh·ªØng g√¨ ch√∫ng ta k·∫øt lu·∫≠n?

				Alain de Botton v√† m√¨nh cho l√† kh√¥ng ph·∫£i nh∆∞ v·∫≠y.

				Ch∆∞∆°ng 19. B√™n ngo√†i Thi·ªán v√† √Åc, Alain vi·∫øt:

				Li·ªáu t√¥i c√≥ t·ªët ƒë·∫πp h∆°n Chloe ch·ªâ v√¨ t√¥i y√™u c√¥ ·∫•y? T·∫•t nhi√™n l√† kh√¥ng, b·ªüi v√¨ m·∫∑c d√π t√¨nh y√™u c·ªßa t√¥i d√†nh cho c√¥ bao h√†m s·ª± hy sinh, t√¥i trao t√¨nh y√™u cho c√¥ v√¨ t√¥i h·∫°nh ph√∫c khi l√†m th·∫ø, t√¥i kh√¥ng hy sinh b·∫£n th√¢n m√¨nh, t√¥i ƒë√£ h√†nh ƒë·ªông ch·ªâ v√¨ n√≥ t∆∞∆°ng h·ª£p qu√° ho√†n h·∫£o v·ªõi nh·ªØng thi√™n h∆∞·ªõng c·ªßa t√¥i, v√¨ n√≥ kh√¥ng ph·∫£i b·ªïn ph·∫≠n.
				D√π kh√¥ng tr·ª±c ti·∫øp ƒë·ªÅ c·∫≠p t·ªõi, nh∆∞ng kh·∫≥ng ƒë·ªãnh tr√™n c·ªßa Alain r·∫•t ph√π h·ª£p v·ªõi thuy·∫øt T∆∞ l·ª£i V·ªã tha (Enlightened self-interest), trong ƒë√≥:

				‚Äúm·ªôt ng∆∞·ªùi h√†nh ƒë·ªông v√¨ l·ª£i √≠ch c·ªßa ng∆∞·ªùi kh√°c (ho·∫∑c l·ª£i √≠ch c·ªßa m·ªôt nh√≥m ho·∫∑c nh·ªØng nh√≥m h·ªç thu·ªôc v·ªÅ), cu·ªëi c√πng l√† ph·ª•c v·ª• l·ª£i √≠ch c·ªßa ch√≠nh h·ªç.‚Äù
				Th·∫±ng Osin kh√¥ng ch·ªâ ƒë∆°n gi·∫£n l√† hy sinh m·ªôt c√°ch m√π qu√°ng, m√† h·ªç ƒëang ƒë√°nh ƒë·ªïi nh·ªØng gi√° tr·ªã h·ªØu h√¨nh (th·ªùi gian, ti·ªÅn b·∫°c‚Ä¶) ƒë·ªÉ nh·∫≠n l·∫°i nh·ªØng gi√° tr·ªã v√¥ h√¨nh (s·ª± tho·∫£ m√£n trong t√¢m h·ªìn, t√¨nh c·∫£m‚Ä¶). V√† v√¨ t√¨nh y√™u lu√¥n lu√¥n l√† m·ªôt tr·∫£i nghi·ªám c√° nh√¢n, l√†m sao b·∫°n c√≥ th·ªÉ hi·ªÉu v√† c·∫£m th·∫•y nh·ªØng gi√° tr·ªã v√¥ h√¨nh m√† Th·∫±ng Osin nh·∫≠n ƒë∆∞·ª£c?

				ƒê·∫øn ƒë√¢y, ch√∫ng ta c√≥ th·ªÉ t·∫°m k·∫øt lu·∫≠n r·∫±ng Th·∫±ng Osin kh√¥ng h·ªÅ ‚Äúcao th∆∞·ª£ng v√† v·ªã tha‚Äù nh∆∞ ch√∫ng ta t∆∞·ªüng, n√™n ch√∫ng ta c√≥ th·ªÉ t·∫°m ng·ª´ng b√†i ca ch·ª≠i r·ªßa v√† b·ªõt ƒëi √Ω ƒë·ªãnh ‚Äúkhai s√°ng‚Äù cho n√≥. Tuy nhi√™n, c√¢u chuy·ªán c·ªßa Th·∫±ng Osin ch∆∞a d·ª´ng l·∫°i t·∫°i ƒë√¢y.

				B·∫°n ƒë√£ ph·∫ßn n√†o hi·ªÉu v√† ng·ª´ng ph√°n x√©t Th·∫±ng Osin, ƒë·ªÉ h·∫Øn m·∫∑c s·ª©c ch√¨m ƒë·∫Øm trong s·ª± ƒëam m√™ v√† kho√°i l·∫°c c·ªßa gi√° tr·ªã v√¥ h√¨nh h·∫Øn ƒëem ƒë√°nh ƒë·ªïi ƒë∆∞·ª£c. Tuy nhi√™n, b·∫°n v·∫´n kh√≥ ch·ªãu v·ªõi c√°ch h√†nh x·ª≠ c·ªßa h·∫Øn, v√† c≈©ng nh∆∞ n·∫øu b·∫°n ƒë·ªÉ √Ω, nhi·ªÅu l√∫c h·∫Øn v·∫´n ho√†i nghi v·ªÅ nh·ªØng g√¨ m√¨nh nh·∫≠n ƒë∆∞·ª£c. C√≥ m·ªôt ƒëi·ªÅu g√¨ ƒë√≥ v·∫´n sai v√† thi·∫øu ·ªü m·ªëi t√¨nh n√†y. T·∫°i sao c·∫£ b·∫°n (ng∆∞·ªùi ‚Äúc√≥ v·∫ª‚Äù kh√°ch quan ƒë·ª©ng ngo√†i) v√† h·∫Øn (ng∆∞·ªùi ch·ªß quan ƒë·ª©ng trong) ƒë·ªÅu c√≥ c·∫£m gi√°c nh∆∞ v·∫≠y?

				C√¢u tr·∫£ l·ªùi n·∫±m ·ªü L√Ω thuy·∫øt Tam gi√°c T√¨nh Y√™u (Triangular theory of love) c·ªßa nh√† t√¢m l√Ω h·ªçc Robert Sternberg:

				M√¥ h√¨nh Tam gi√°c T√¨nh y√™u
				Nh∆∞ l√Ω thuy·∫øt n√†y cho th·∫•y, m·ªôt t√¨nh y√™u ‚Äúho√†n h·∫£o‚Äù ch·ªâ xu·∫•t hi·ªán khi ƒë·ªß 3 y·∫øu t·ªë: T√≠nh th√¢n m·∫≠t ‚Äî ƒêam m√™ ‚Äî Cam k·∫øt. R√µ r√†ng nh·ªØng gi√° tr·ªã v√¥ h√¨nh Th·∫±ng Osin nh·∫≠n ƒë∆∞·ª£c ch·ªâ ƒë√°p ·ª©ng ƒë∆∞·ª£c hai ƒë·ªânh T√≠nh th√¢n m·∫≠t v√† ƒêam m√™. S·ª± thi·∫øu h·ª•t Cam k·∫øt t·∫°o ra c·∫£m gi√°c b·∫•t an v√† m·∫•t an to√†n v·ªÅ m·ªëi quan h·ªá n√†y, k√©o theo l√† nh·ªØng ƒë√™m d√†i m·∫•t ng·ªß suy nghƒ© v√† c·∫£m gi√°c k·∫øt th√∫c r√µ r√†ng lu√¥n th·∫•y tr∆∞·ªõc c·ªßa Th·∫±ng Osin. ƒê√¢y l√† l√≠ do d√π say ƒë·∫Øm t·ªõi nh∆∞·ªùng n√†o, ch√∫ng ta v·∫´n c·∫ßn nh·ªØng l·ªùi t·ªè t√¨nh, nh·ªØng b·ª©c ·∫£nh, tuy√™n b·ªë c√¥ng khai‚Ä¶ ƒë·ªÉ t·ª± an ·ªßi m√¨nh v·ªÅ s·ª± ch·∫Øc ch·∫Øn c·ªßa m·ªëi quan h·ªá.

				Th·∫≠t t·ªôi nghi·ªáp Th·∫±ng Osin, v√¨ h·∫Øn s·∫Ω ch·∫≥ng bao gi·ªù c√≥ ƒë∆∞·ª£c ƒëi·ªÅu ƒë√≥‚Ä¶

				C√≥ th·ªÉ ƒë·∫øn ƒë√¢y b·∫°n s·∫Ω h·ªèi, v·∫≠y li·ªáu Th·∫±ng Osin c√≥ n√™n ti·∫øp t·ª•c m·ªëi quan h·ªá v·ª´a sung s∆∞·ªõng v·ª´a kh·ªï ƒëau n√†y? Th·∫≠t kh√≥ ƒë·ªÉ tr·∫£ l·ªùi. S·∫Ω ch·∫≥ng bao gi·ªù c√≥ m·ªôt c√¥ng th·ª©c chung trong t√¨nh y√™u, v√¨ d√π n√£o b·ªô ch√∫ng ta c√≥ logic v√† si√™u vi·ªát ƒë·∫øn nh∆∞·ªùng n√†o, hormone v√† tr√°i tim lo·∫°n nh·ªãp khi y√™u l√†m s·∫Ω l√†m n√≥ l√∫ l·∫´n h·∫øt c·∫£ ƒëi. Tuy nhi√™n, ch√∫ng ta c√≥ th·ªÉ ƒë∆∞a cho h·∫Øn m·ªôt s·ªë c√¥ng c·ª• ƒë·ªÉ h·∫Øn t·ª± soi r·ªçi v√†o t√¨nh y√™u c·ªßa h·∫≥n.

				V√¨ sao con ng∆∞·ªùi l·∫°i Y√™u? Ch√∫ng ta ƒë√¢m ƒë·∫ßu v√†o y√™u, y√™u l·∫•y y√™u ƒë·ªÉ, y√™u h√πng h·ª•c, y√™u d√π bi·∫øt ƒë·∫Øng cay kh·ªï ƒëau nh·ª•c nh√£ c≈©ng kh√¥ng thi·∫øu g√¨ b√™n c·∫°nh nh·ªØng sung s∆∞·ªõng ƒëam m√™ t√™ d·∫°i? Ph·∫£i c√≥ m·ªôt ƒë·ªông l·ª±c gh√™ g·ªõm l·∫Øm khi·∫øn c·∫£ lo√†i ng∆∞·ªùi ph√°t ƒëi√™n l√™n v√¨ y√™u nh∆∞ v·∫≠y (t·∫°m th·ªùi ch√∫ng ta s·∫Ω b·ªè qua nhu c·∫ßu duy tr√¨ n√≥i gi·ªëng). Trong Tuy√™n ng√¥n ƒê·ªôc l·∫≠p Hoa K·ª≥ c√≥ n√≥i t·ªõi ba quy·ªÅn c∆° b·∫£n nh·∫•t c·ªßa con ng∆∞·ªùi g·ªìm Quy·ªÅn ƒë∆∞·ª£c s·ªëng, quy·ªÅn t·ª± do v√† quy·ªÅn m∆∞u c·∫ßu h·∫°nh ph√∫c. Con ng∆∞·ªùi y√™u, v√¨ con ng∆∞·ªùi m∆∞u c·∫ßu h·∫°nh ph√∫c. C√¥ng th·ª©c c·ªßa h·∫°nh ph√∫c nh∆∞ sau:

				it‚Äôs not simple as it looks, dude‚Ä¶
				C√¥ng th·ª©c n√†y ƒë∆∞·ª£c hai nh√† kinh t·∫ø h·ªçc Manel Baucells v√† Rakesh Sarin ƒë∆∞a ra v√†o nƒÉm 2011. M·ªôt ph∆∞∆°ng tr√¨nh ƒë∆°n gi·∫£n gi·ªØa Th·ª±c t·∫ø v√† K√¨ v·ªçng. Khi Th·ª±c t·∫ø l·ªõn h∆°n K√¨ v·ªçng, b·∫°n h·∫°nh ph√∫c. Khi K√¨ v·ªçng l·ªõn h∆°n Th·ª±c t·∫ø, ƒë√≥ l√† m·∫ßm m·ªëng kh·ªï ƒëau v√† tuy·ªát v·ªçng.

				B√™n c·∫°nh nh·ªØng gi√° tr·ªã v√¥ h√¨nh, k√¨ v·ªçng ch√≠nh l√† ƒë·ªông l·ª±c th√∫c ƒë·∫©y Th·∫±ng Osin theo ƒëu·ªïi m·ªëi quan h·ªá mang t√≠nh ch·∫•t kh√° m·ªôt chi·ªÅu n√†y. K√¨ v·ªçng v·ªÅ m·ªôt t∆∞∆°ng lai c√¥ ·∫•y s·∫Ω c·∫£m ƒë·ªông, c√¥ ·∫•y s·∫Ω y√™u m√¨nh, c√¥ ·∫•y s·∫Ω‚Ä¶ K√¨ v·ªçng lu√¥n lu√¥n c√≥ m·ªôt s·ª©c m·∫°nh l·ª´a ph·ªânh r·∫•t to l·ªõn, v√¨ ch√∫ng cho ch√∫ng ta s·ª± y√™n t√¢m, nh∆∞ng l√† y√™n t√¢m trong th√¨ t∆∞∆°ng lai. N√≥i c√°ch kh√°c, ch√≠nh nh·ªØng k√¨ v·ªçng n√†y ƒë√£ t·∫°o ra m·ªôt ƒë·ªânh Cam k·∫øt ‚Äú·∫£o c·ªßa th√¨ t∆∞∆°ng lai‚Äù trong Tam gi√°c T√¨nh y√™u, khi·∫øn Th·∫±ng Osin nghƒ© r·∫±ng ƒë√¢y ch√≠nh l√† ‚Äút√¨nh y√™u ho√†n h·∫£o‚Äù c·ªßa ƒë·ªùi h·∫Øn. Th·∫±ng Osin ƒë√£ r∆°i v√†o c√°i b·∫´y t·ª± huy·ªÖn ho·∫∑c b·∫£n th√¢n l√∫c n√†o kh√¥ng bi·∫øt.

				ƒê√£ ƒë·∫øn l√∫c ng·ªìi l·∫°i, b√¨nh tƒ©nh nh√¨n v√†o s·ª± th·∫≠t r·ªìi, anh b·∫°n‚Ä¶

				M√¨nh vi·∫øt kh√¥ng nh·∫±m m·ª•c ƒë√≠ch ch·ªâ ra th·∫ø n√†o l√† y√™u ƒë√∫ng, y√™u sai. M√¨nh cho r·∫±ng t√¨nh y√™u l√† l√£nh ƒë·ªãa huy·ªÅn b√≠ c·ªßa c·∫£m x√∫c, nh·ªØng ph√¢n t√≠ch t√¢m l√≠ hay tri·∫øt h·ªçc s√¢u s·∫Øc ƒë·∫øn nh∆∞·ªùng n√†o c≈©ng kh√¥ng th·ªÉ bao tr√πm h·∫øt √Ω nghƒ©a c·ªßa t√¨nh y√™u. M√¨nh ch·ªâ mong c√°c b·∫°n n√†o ki√™n nh·∫´n ƒë·ªçc h·∫øt b√†i vi·∫øt n√†y (ch·∫Øc l√† b·∫°n c≈©ng ƒëang y√™u?), h√£y m·ªü l√≤ng v√† v·ªã tha h∆°n v·ªõi s·ª± m√π qu√°ng c·ªßa nh·ªØng k·∫ª ƒëang y√™u. V√¨ b·∫£n th√¢n t√¨nh y√™u ƒë√¢u c√≥ t·ªôi, ƒë√∫ng kh√¥ng?

				T√°i b√∫t: D√π vi·∫øt c√≥ v·∫ª logic v√† deep nh∆∞ v·∫≠y nh∆∞ng t√°c gi·∫£ y√™u v√†o c≈©ng l√∫ b·ªè m·∫π, n√™n c√°c b·∫°n c·ª© y√™u nhi·ªát ƒëi, nghƒ© l√†m g√¨ cho m·ªát ihihi

				- ngu·ªìn https://www.linkedin.com/pulse/lu%E1%BA%ADn-v%E1%BB%81-y%C3%AAu-hay-l%C3%A0-con-ch%C3%B3-v%C3%A0-th%E1%BA%B1ng-osin-nguy%E1%BB%85n-duy-qu%C3%AD
			*/
		}
		void LIGHT(int num)
		{
			// cout << "light " << num << endl;
			if (num>0) {
				customer *temp = table->get();
				int len = table->getSize();
				for (int i=0;i<len;i++){
					cout << temp->name << "-" << temp->energy << endl;
					temp = temp->next;
				}
			} else if (num<0) {
				customer *temp = table->get();
				int len = table->getSize();
				for (int i=0;i<len;i++){
					cout << temp->name << "-" << temp->energy << endl;
					temp = temp->next;
				}
			} else {
				int len = queue->getSize();
				for (int i=0;i<len;i++){
					cout << queue->getat(i)->name << "-" << queue->getat(i)->energy << endl;
				}
			}
		}
};
//main.cpp
void simulate(string filename, imp_res* r)
{
	ifstream ss(filename);
	string str, maxsize, name, energy, num;
	while(ss >> str)
	{ 
		if(str == "MAXSIZE")
		{
			ss >> maxsize;
			MAXSIZE = stoi(maxsize); 
    	}
        else if(str == "RED") // RED <NAME> <ENERGY>
        {
            ss >> name;
            ss >> energy;
            r->RED(name, stoi(energy));
    	}
    	else if(str == "BLUE") // BLUE <NUM>
    	{
                ss >> num;
    			r->BLUE(stoi(num));
		}
    	else if(str == "PURPLE") // PURPLE
    	{
    			r->PURPLE();
		}
		else if(str == "REVERSAL") // REVERSAL
		{
    			r->REVERSAL();	
		}
    	else if(str == "UNLIMITED_VOID") // UNLIMITED_VOID
     	{   	
    			r->UNLIMITED_VOID();
    	}
    	else if(str == "DOMAIN_EXPANSION") // DOMAIN_EXPANSION
    	{
    			r->DOMAIN_EXPANSION();
    	}
    	else // LIGHT <NUM>
    	{
                ss >> num;
    			r->LIGHT(stoi(num));
    	}
    }
}

int main(int argc, char* argv[]) {
	//if (argc < 2)
    //	return 1;
	//  string fileName = argv[1];
	imp_res* r = new imp_res();
	string fileName = "test.txt";
    simulate(fileName, r);
  	delete r;
	return 0;
}

